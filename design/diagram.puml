@startuml
package "GameLogic" {
    class ActionUtil {
      + convertObjToAction(t: Object): Action
      + registerRawAction(action: Action, remoteRawActions: Space): void
      + handleRawAction(lastActionsClock: int, index: int, action: Action, cleanActions: Space): void
  }
    class ClientMain {
      + main(args: String): void
  }
    class GameController {
      + updateGameStateFor(gameState: GameState, tarclock: int): GameState
      + deepCopyGameState(state: GameState): GameState
      + updateGameState(gameState: GameState, actions: List): GameState
      + initializeGameState(nrOfPlayers: int): GameState
      + allPlayersDead(gameState: GameState): boolean
      + allPointsGathered(gameState: GameState): boolean
  }
    class URIUtil {
      + getLobbyID(lobbySpecificURI: String): int
      + getSyncURI(baseURI: String, lobbyId: int): String
      + getRawActionURI(baseURI: String, lobbyId: int): String
      + getCleanActionURI(baseURI: String, lobbyId: int): String
      + getSpace1URI(baseURI: String): String
  }
  package "ClientComs" {
        class ConnectToLobby {
        - nrOfPlayers: int
        - playerID: int
        - lobbyID: int
        - sync: Space
        - reader: Reader
        - space1: Space
        - isLobbyOpen: boolean
        + createLobby(nrOfPlayers: int): void
        + joinLobby(lobbyID: String): void
        + leaveLobby(): void
        + isPlayerInGame(playerID: int): boolean
        + startGame(): void
        + quit(): void
    }
        class KeyHandler {
        - rawActions: Space
        - playerID: int
        + move(key: KeyCode): void
        + moveUp(): void
        + moveDown(): void
        + moveLeft(): void
        + moveRight(): void
    }
        class Reader implements Runnable {
        - lobbyID: int
        - running: boolean
        + isConnected(): boolean
        + run(): void
        + stop(): void
    }
  }
}
package "GUI" {
    class SoundEngine {
      + disabled: boolean
      - soundPlayers: Map
      - soundLoopers: Map
      + play(sound: Sound): void
      + loop(sound: Sound): void
      + stop(sound: Sound): void
      + setVolume(volume: double): void
  }
    enum SpriteSheet {
      OBJECT_SHEET
      WALL_SHEET
      PLAYER_YELLOW
      PLAYER_RED
      PLAYER_GREEN
      PLAYER_BLUE
      PLAYER_WHITE
      WALL_COLORED
      + image: Image
      + pixelsPerTile: int
      - createColoredPlayerImage(color: Color): Image
      - createColoredWallImage(color: Color): Image
      + getPlayerSheet(color: Color): SpriteSheet
  }
    class UI extends Application {
      - soundEngine: SoundEngine
      - lobbyHandler: ConnectToLobby
      - gameController: GameController
      - gameState: GameState
      - savedState: GameState
      - gc: GraphicsContext
      - canvas: Canvas
      - keyHandler: KeyHandler
      - createLobby: Runnable
      - notificationText: Text
      - eatingDot: boolean
      - animationTimeNanos: long
      + FONT_FAMILY: String
      + TilePos(x: int, y: int): record
      + stop(): void
      + start(stage: Stage): void
      + notifyDisconnection(message: String): void
  }
}
package "model" {
    class Action {
      - playerId: int
      - clock: int
      - move: int
      - index: int
      + clock(): int
  }
    class ActionList {
      - actionsMap: Map
      - actionsList: List
      - nrOfActionsCalled: int
      - playerID: int
      + addAction(action: Action): void
      + getActions(clock: int): List
      + missedAction(clock: int): boolean
  }
    class Constants {
      + LOBBY_TTL: long
      + NR_OF_LOBBYS_CAP: int
      + cleanActions: ActionList
      + REMOTE_PUBLIC_URI: String
      + LOCAL_GATE: String
      + TILES_WIDE: int
      + TILES_TALL: int
      + TILE_SIZE: int
      + INIT_SCREEN_WIDTH: int
      + INIT_SCREEN_HEIGHT: int
      + TARGET_FPS: long
      + CENTER_EPS_PX: double
      + COUNTDOWN_DURATION_TICKS: int
      + COLLISION_DISTANCE_PVG: double
      + COLLISION_DISTANCE_PVP: double
      + FRUIT_RESPAWN_DELAY_SEC: double
      + TIME_OFFSET_CAP: double
      + PLAYER_LIVES: int
      + PLAYER_SPEED: double
      + PLAYER_FRIGHTENED_SPEED: double
      + PLAYER_SPAWN_PROTECT_SEC: double
      + PLAYER_RESPAWN_DELAY_SEC: double
      + GHOST_SPEED: double
      + GHOST_FRIGHTENED_SPEED: double
      + GHOST_RESPAWN_SPEED: double
      + GHOST_RESPAWN_DELAY_SEC: double
      + FRIGHTENED_DURATION_SEC: double
      + clock: int
      + actionOffset: int
      + timeOffset: long
  }
    enum Direction {
      NORTH
      EAST
      SOUTH
      WEST
  }
    abstract Entity {
      + position: Position
      + direction: Direction
      + spawnPosition: Position
      + respawnTimer: double
      + update(): void
      + distanceTo(e: Entity): double
  }
    class EntityTracker {
      - ghostScatterMode: boolean
      - ghostChaseTimer: double
      - frightenedTimerSec: double
      - powerOwnerId: int
      - fruitCooldownTimer: double
      - fruitOnMap: boolean
      + clearPowerOwner(): void
      + isAnyPowerActive(): boolean
      + isPowerOwner(p: Player): boolean
      + assignPowerTo(owner: Player): void
      + clearPowerIfOwnerInvalid(players: List): boolean
      + isPlayerFrightened(player: Player): boolean
      + copy(): EntityTracker
  }
    class Unknown {
  }
    class Ghost extends Entity {
      - type: GhostType
      + copy(): Ghost
  }
    enum GhostType {
      RED
      PINK
      CYAN
      ORANGE
      PURPLE
      + name: String
  }
    class Maps {
      - currentLevel: Level
      + getCurrentLevelTiles(): TileType
      + getGhostSpawnTile(ghostType: GhostType): Pair
      + getPlayerSpawnTile(playerId: int): Pair
      + getFruitToSpawn(totalPoints: int): TileType
      + incrementLevel(): void
  }
    class Player extends Entity {
      - id: int
      - ghostsEatenThisEnergizer: int
      - points: int
      - lives: int
      - intendedDirection: Direction
      - alive: boolean
      - powerUpTimer: double
      - invulnerableTimer: double
      - lostHeart: boolean
      - ateFruit: boolean
      - ateGhost: boolean
      - atePowerUp: boolean
      - deadWithNoHearts: boolean
      + addPoints(points: int): void
      + resetGhostsEatenThisEnergizer(): void
      + eatGhost(): void
      + loseLife(): int
      + isDead(): boolean
      + getColor(): Color
      + isInvulnerable(): boolean
      + copy(): Player
  }
    class Position {
      + x: double
      + y: double
      + ToGridPosition(): Pair
      + fromGridPosition(gridPos: Pair): Position
      + ToScreenPosition(): Pair
  }
    enum Sound {
      CREDIT
      START_MUSIC
      EAT_DOT
      TURNING_CORNER
      EXTEND
      GHOST_NORMAL
      GHOST_SPURT_1
      GHOST_SPURT_2
      GHOST_SPURT_3
      GHOST_SPURT_4
      EAT_FRUIT
      GHOST_BLUE
      EAT_GHOST
      GHOST_HOME
      FAIL
      COFFEE_BREAK
      - path: String
      + getPath(): String
  }
    enum TileType {
      EMPTY
      WALL
      PAC_DOT
      ENERGIZER
      CHERRY
      STRAWBERRY
      ORANGE
      APPLE
      MELON
      GALAXIAN
      BELL
      KEY
      WALL10
      WALL11
      WALL12
      + points: int
  }
}
package "ServerLogic" {
    class Lobby implements Runnable {
      - rep: SpaceRepository
      - nrOfPlayers: int
      - actionHandler: LobbyActionHandler
      - lobbyID: int
      - timeOfCreation: long
      + run(): void
      + stop(): void
  }
    class LobbyActionHandler implements Runnable {
      + repository: SpaceRepository
      + lobbyID: int
      + running: boolean
      + run(): void
      + stop(): void
  }
    class LobbyCleaner implements Runnable {
      - lobbys: List
      - space1: Space
      - running: boolean
      - toBeAdded: List
      - showActiveLobbys: boolean
      - closeAllLobbys: boolean
      + run(): void
      + closeAllLobbys(): void
      + showActiveLobbys(): void
      + stop(): void
      + addLobby(lobby: Lobby): void
  }
    class ServerController {
      - lobbys: List
      - rep: SpaceRepository
      - space1: Space
      + main(arg: String): void
  }
    class ServerIO implements Runnable {
      + lobbyCleaner: LobbyCleaner
      + run(): void
      - help(): void
      - invalidIndput(): void
  }
}
  ConnectToLobby o-- Reader: contains
  UI o-- SoundEngine: contains
  UI o-- ConnectToLobby: contains
  UI o-- GameController: contains
  UI o-- KeyHandler: contains
  Constants o-- ActionList: contains
  Entity "1" o-- "many" Position: contains
  ActionList "1" o-- "many" Action: contains
  LobbyCleaner "1" o-- "many" Lobby: contains
  ServerController "1" o-- "many" Lobby: contains
  Entity o-- Direction: contains
  Ghost o-- GhostType: contains
  Player o-- Direction: contains
  Lobby o-- LobbyActionHandler: contains
  ServerIO o-- LobbyCleaner: contains
@enduml
