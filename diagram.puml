@startuml
package "GameLogic" {
    class ActionUtil {
      + convertObjToAction(t: Object): Action
      + registerRawAction(action: Action, remoteRawActions: Space): void
      + handleRawAction(lastActionsClock: int, index: int, action: Action, cleanActions: Space): void
  }
    class ClientGameController extends GameController {
      + updateGameStateFor(gameState: GameState, tarclock: int): GameState
      + deepCopyGameState(state: GameState): GameState
      + updateGameState(gameState: GameState, actions: List): GameState
      - handleFruitSpawning(gameState: GameState): void
      + initializeGameState(nrOfPlayers: int): GameState
      - handleActions(gameState: GameState, actions: List): void
      - stepMovement(gameState: GameState): void
      - handlePlayerGridPosition(gameState: GameState): void
      - directionFromMove(move: int): Direction
      - isWall(tiles: TileType, x: double, y: double): boolean
      - getGhostDir(ghost: Ghost): Direction
      - oppositeDir(dir: Direction): Direction
      - countWalkableNeighbors(tiles: TileType, x: int, y: int): int
      - isWalkable(tiles: TileType, x: int, y: int): boolean
      - isWalkableInDir(tiles: TileType, x: int, y: int, d: Direction): boolean
      - chooseBestDirTowardTarget(tiles: TileType, gx: int, gy: int, currentDir: Direction, targetX: int, targetY: int): Direction
      - chooseBestDirAwayFromPlayer(tiles: TileType, gx: int, gy: int, currentDir: Direction, playerX: int, playerY: int): Direction
      - findNearestPlayer(gameState: GameState, ghost: Ghost): Player
      - getScatterCorner(gameState: GameState, ghost: Ghost): Pair
      - computeGhostTargetTile(gameState: GameState, ghost: Ghost, pac: Player, blinky: Ghost): Pair
      - GhostMovement(gameState: GameState): void
      - handleGhostPlayerCollisions(gameState: GameState): void
      - updateRespawnTimers(gameState: GameState): void
      - updatePlayerPowerTimers(gameState: GameState): void
      - isPowered(p: Player, entityTracker: EntityTracker): boolean
      - handlePvPcollitions(gameState: GameState): void
      - isPlayerCollidable(p: Player): boolean
      - eatPlayer(gameState: GameState, eater: Player, victim: Player): void
      - resolvePlayerOverlap(a: Player, b: Player): void
      - updateInvulnerabilityTimers(gameState: GameState): void
      - isInvulnerable(p: Player): boolean
      + allPlayersDead(gameState: GameState): boolean
      + allPointsGathered(gameState: GameState): boolean
      - getWinner(gameState: GameState): Player
  }
    class ClientMain {
      + main(args: String): void
  }
    abstract GameController {
      + updateGameState(gameState: GameState, actions: List): GameState
      - update(): void
  }
    abstract ServerGameController extends GameController {
  }
    class URIUtil {
      + getLobbyID(lobbySpecificURI: String): int
      + getSyncURI(baseURI: String, lobbyId: int): String
      + getRawActionURI(baseURI: String, lobbyId: int): String
      + getCleanActionURI(baseURI: String, lobbyId: int): String
      + getSpace1URI(baseURI: String): String
      - buildLobbyURI(baseURI: String, lobbyId: int, actionSuffix: String): String
      - parse(uri: String): URI
      - buildLobbyURI(baseURI: String, actionSuffix: String): String
  }
  package "ClientComs" {
        class ConnectToLobby {
        - nrOfPlayers: int
        - playerID: int
        - lobbyID: int
        - sync: Space
        - reader: Reader
        + createLobby(nrOfPlayers: int): void
        + joinLobby(lobbyID: String): void
        + joinLobby(lobbyID: String, timeoutMs: long): void
        + leaveLobby(): void
        + getGameState(): Object
        + isPlayerInGame(playerID: int): boolean
        + startGame(): void
        + quit(): void
        + getLobbyID(): int
        + getNrOfPlayers(): int
        + getPlayerID(): int
    }
        class KeyHandler {
        - rawActions: Space
        - playerID: int
        + move(key: KeyCode): void
        + moveUp(): void
        + moveDown(): void
        + moveLeft(): void
        + moveRight(): void
    }
        class Reader implements Runnable {
        - lobbyID: int
        - running: boolean
        + isConnected(): boolean
        + run(): void
        + stop(): void
    }
  }
  package "ClientThreads" {
  }
}
package "GUI" {
    class SoundEngine {
      + disabled: boolean
      - soundPlayers: Map
      - soundLoopers: Map
      + play(sound: Sound): void
      + loop(sound: Sound): void
      + stop(sound: Sound): void
      + setVolume(volume: double): void
  }
    class UI extends Application {
      - soundEngine: SoundEngine
      - lobbyHandler: ConnectToLobby
      - gameController: ClientGameController
      - gameState: GameState
      - savedState: GameState
      - gc: GraphicsContext
      - canvas: Canvas
      - spriteSheet: Image
      - wallSpriteSheet: Image
      - coloredPlayerCache: Map
      - keyHandler: KeyHandler
      - createLobby: Runnable
      - notificationText: Text
      - eatingDot: boolean
      - animationTimeNanos: long
      + FONT_FAMILY: String
      + TilePos(x: int, y: int): record
      + stop(): void
      + start(stage: Stage): void
      - colorPlayer(color: Color): Image
      - precomputePlayerColors(): void
      - createColoredPlayerImage(color: Color): Image
      - initializeMainMenu(stage: Stage): void
      + notifyDisconnection(message: String): void
      - startLobby(stage: Stage): void
      - startGame(stage: Stage): void
      - drawTileFromTileset(gc: GraphicsContext, tileset: Image, tileX: int, tileY: int, destX: double, destY: double): void
      - drawTileFromTileset(gc: GraphicsContext, tileset: Image, tileX: int, tileY: int, srcOffsetX: int, srcOffsetY: int, srcWidth: int, srcHeight: int, destX: double, destY: double): void
      - drawRectangle(gc: GraphicsContext, x: int, y: int, width: int, height: int): void
      - createTiledButton(text: String, tilesWide: int, tilesTall: int): Button
      - createTiledImageView(width: double, height: double): ImageView
  }
}
package "model" {
    class Action {
      - playerId: int
      - clock: int
      - move: int
      - index: int
      + getPlayerId(): int
      + clock(): int
      + getMove(): int
      + getIndex(): int
      + setClock(clock: int): void
  }
    class ActionList {
      - actionsMap: Map
      - actionsList: List
      - nrOfActionsCalled: int
      - playerID: int
      + addAction(action: Action): void
      + getActions(clock: int): List
      + missedAction(clock: int): boolean
  }
    class Constants {
      + LOBBY_TTL: long
      + NR_OF_LOBBYS_CAP: int
      + cleanActions: ActionList
      + REMOTE_PUBLIC_URI: String
      + LOCAL_GATE: String
      + TILES_WIDE: int
      + TILES_TALL: int
      + TILE_SIZE: int
      + INIT_SCREEN_WIDTH: int
      + INIT_SCREEN_HEIGHT: int
      + TARGET_FPS: long
      + CENTER_EPS_PX: double
      + COUNTDOWN_DURATION_TICKS: int
      + COLLISION_DISTANCE_PVG: double
      + COLLISION_DISTANCE_PVP: double
      + FRUIT_RESPAWN_DELAY_SEC: double
      + PLAYER_LIVES: int
      + PLAYER_SPEED: double
      + PLAYER_FRIGHTENED_SPEED: double
      + PLAYER_SPAWN_PROTECT_SEC: double
      + PLAYER_RESPAWN_DELAY_SEC: double
      + GHOST_RESPAWN_DELAY_SEC: double
      + FRIGHTENED_DURATION_SEC: double
      + clock: int
      + actionOffset: int
      + timeOffset: long
  }
    enum Direction {
      NORTH
      EAST
      SOUTH
      WEST
  }
    abstract Entity {
      + position: Position
      + direction: Direction
      + spawnPosition: Position
      + respawnTimer: double
      + update(): void
      + distanceTo(e: Entity): double
  }
    class EntityTracker {
      - ghostSpeed: double
      - ghostScatterMode: boolean
      - ghostChaseTimer: double
      - frightenedTimerSec: double
      - powerOwnerId: int
      - fruitCooldownTimer: double
      - fruitOnMap: boolean
      + clearPowerOwner(): void
      + isAnyPowerActive(): boolean
      + isPowerOwner(p: Player): boolean
      + assignPowerTo(owner: Player): void
      + clearPowerIfOwnerInvalid(players: List): boolean
      + isPlayerFrightened(player: Player): boolean
      + copy(): EntityTracker
  }
    class Unknown {
  }
    class Ghost extends Entity {
      - type: GhostType
      + copy(): Ghost
  }
    enum GhostType {
      RED
      PINK
      CYAN
      ORANGE
      PURPLE
      + name: String
  }
    class Maps {
      - currentLevel: Level
      + getCurrentLevelTiles(): TileType
      + getGhostSpawnTile(ghostType: GhostType): Pair
      + getPlayerSpawnTile(playerId: int): Pair
      + getFruitToSpawn(totalPoints: int): TileType
      + incrementLevel(): void
  }
    class Player extends Entity {
      - id: int
      - ghostsEatenThisEnergizer: int
      - points: int
      - lives: int
      - intendedDirection: Direction
      - alive: boolean
      - powerUpTimer: double
      - invulnerableTimer: double
      - lostHeart: boolean
      - ateFruit: boolean
      - ateGhost: boolean
      - atePowerUp: boolean
      - deadWithNoHearts: boolean
      + addPoints(points: int): void
      + resetGhostsEatenThisEnergizer(): void
      + eatGhost(): void
      + loseLife(): int
      + isDead(): boolean
      + getColor(): Color
      + isInvulnerable(): boolean
      + copy(): Player
  }
    class Position {
      + x: double
      + y: double
      + ToGridPosition(): Pair
      + fromGridPosition(gridPos: Pair): Position
      + ToScreenPosition(): Pair
  }
    enum Sound {
      CREDIT
      START_MUSIC
      EAT_DOT
      TURNING_CORNER
      EXTEND
      GHOST_NORMAL
      GHOST_SPURT_1
      GHOST_SPURT_2
      GHOST_SPURT_3
      GHOST_SPURT_4
      EAT_FRUIT
      GHOST_BLUE
      EAT_GHOST
      GHOST_HOME
      FAIL
      COFFEE_BREAK
      - path: String
      + getPath(): String
  }
    enum TileType {
      EMPTY
      WALL
      PAC_DOT
      ENERGIZER
      CHERRY
      STRAWBERRY
      ORANGE
      APPLE
      MELON
      GALAXIAN
      BELL
      KEY
      WALL10
      WALL11
      WALL12
      + points: int
  }
}
package "ServerLogic" {
    class Lobby implements Runnable {
      - rep: SpaceRepository
      - nrOfPlayers: int
      - actionHandler: LobbyActionHandler
      - lobbyID: int
      - timeOfCreation: long
      + run(): void
      + stop(): void
      + getRep(): SpaceRepository
  }
    class LobbyActionHandler implements Runnable {
      + repository: SpaceRepository
      + lobbyID: int
      + running: boolean
      + run(): void
      + stop(): void
  }
    class LobbyCleaner implements Runnable {
      - lobbys: List
      - space1: Space
      - running: boolean
      - toBeAdded: List
      - showActiveLobbys: boolean
      - closeAllLobbys: boolean
      + run(): void
      + closeAllLobbys(): void
      + showActiveLobbys(): void
      + stop(): void
      + addLobby(lobby: Lobby): void
  }
    class ServerController {
      - lobbys: List
      - rep: SpaceRepository
      - space1: Space
      + main(arg: String): void
  }
    class ServerIO implements Runnable {
      + lobbyCleaner: LobbyCleaner
      + run(): void
      - help(): void
      - invalidIndput(): void
  }
}
  ConnectToLobby o-- Reader: contains
  UI o-- SoundEngine: contains
  UI o-- ConnectToLobby: contains
  UI o-- ClientGameController: contains
  UI o-- KeyHandler: contains
  Constants o-- ActionList: contains
  Entity "1" o-- "many" Position: contains
  Entity o-- Direction: contains
  Ghost o-- GhostType: contains
  Player o-- Direction: contains
  Lobby o-- LobbyActionHandler: contains
  ServerIO o-- LobbyCleaner: contains
@enduml